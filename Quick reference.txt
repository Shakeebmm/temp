(asp.net ,c#,oops,Silverlight,wcf).

1.	Generics
	A very simple example is the generic List<T> class. It can hold a number of objects of any type. For example, you can declare a list of strings (new List<string>()) or a list of Animals (new List<Animal>()), because it is generic.What if you couldn't use generics? You could use the ArrayList class, but the downside is that it's containing type is an object. So when you'd iterate over the list, you'd have to cast every item to its correct type (either string or Animal) which is more code and has a performance penalty. Plus, since an ArrayList holds objects, it isn't type-safe. You could still add an Animal to an ArrayList of strings.
	generics still enable type safety! So if you try this, you will rightly get an error:

	//  continued for snippet above
	Order anotherOrder = new Order();
	customers.Add(anotherOrder);    //  FAIL!
	
	In a nutshell, generics allow you to write classes that work with objects of any type, but without having to cast the data to Object. There are performance benefits for this, but it also makes your code more readable, maintainable, and less error-prone.
	
2.	dependency property
	Dependency property is like the property basically belongs to some other class and is used in other class
	TextBlock.Text is dependent on the Binding, and the Binding is dependent on the DataContext in this case.  The DataContext is inheriting down from the StackPanel, so the Text property is therefore also dependent on the shape of the tree; if the TextBlock is removed from the StackPanel, it’s Text property will update
3.	attached prpoety
	With an attached property, the property is defined on a class that isn't the same class for which it's being used. This is usually used for layout. Good examples are Panel.ZIndex or Grid.Row - you apply this to a control (ie: Button), but it's actually defined in Panel or Grid. The property is "attached" to the button's instance.
4.	dependecy  injection
	Log - file system, db or event viewer
5.	is and as keywords
	The is operator in C# is used to check the object type and it returns a bool value: true if the object is the same type and false if not.
	For null objects, it returns false.
	
	The as operator does the same job of is operator but the difference is instead of bool, it returns the object if they are compatible to that type, else it returns null.
6.	ienumerable 
	IEnumerable describes behavior, while List is an implementation of that behavior
	 yield which actually facilitate the enumeration over collection. yield statement is used while returning a value from a function.
	 When you use IEnumerable, you give the compiler a chance to defer work until later, possibly optimizing along the way. If you use ToList() you force the compiler to reify the results right away.
	 An IEnumerable is a thing that can be enumerated.which simply means that it has a GetEnumerator method that returns an IEnumerator.
6.	IComparable
	The role of IComparer is to provide additional comparison mechanisms. For example, you may want to provide ordering of your class on several fields or properties, ascending and descending order on the same field, or both. 
	Using IComparer is a two-step process. First, declare a class that implements IComparer, and then implement the Compare method:
7.	lazy initialization
	lazy initialization is delaying initialization until a component or object is used. 
	The advantages from an application perspective of lazy initialization are that users don't have to pay the initialization time for features they will not use. Suppose you were to initialize every component of your application up front. This could create a potentially long start time 
	Instead, if you defer initializing those components until use time, your application will start up much quicker.
	
	The .NET Framework defines a class named Lazy<T>, which itself incorporates the Lazy Loading behaviour. The Lazy<T> class needs two basic information regarding the object that's going to be "lazily" initialized:
	Its type (specified in the type parameter)
	How to load its value (i.e. which function should be called)
8.	late binding
	Compile Time Polymorphism or Early Binding

	Compile time polymorphism means we will declare methods with same name but different signatures because of this we will perform different tasks with same method name. This compile time polymorphism also called as early binding or method overloading.

	Method Overloading or compile time polymorphism means same method names with different signatures (different parameters)

	Run Time Polymorphism or Late Binding

	Run time polymorphism also called as late binding or method overriding or dynamic polymorphism. Run time polymorphism or method overriding means same method names with same signatures.

	In this run time polymorphism or method overriding we can override a method in base class by creating similar function in derived class this can be achieved by using inheritance principle and using “virtual & override” keywords.
9.	static and dynamic resource - SL
	A StaticResource will be resolved and assigned to the property during the loading of the XAML which occurs before the application is actually run. It will only be assigned once and any changes to resource dictionary ignored.

	A DynamicResource assigns an Expression object to the property during loading but does not actually lookup the resource until runtime when the Expression object is asked for the value. This defers looking up the resource until it is needed at runtime. A good example would be a forward reference to a resource defined later on in the XAML. Another example is a resource that will not even exist until runtime. It will update the target if the source resource dictionary is changed.
10.	POCO
	POCO(Plain old CLR objects)
11.	Var/object/dynamic
	var
	Statically typed – This means the type of variable declared is decided by the compiler at compile time.
	Need to initialize at the time of declaration.
	Errors are caught at compile time.
	Visual Studio shows intellisense since the type of variable assigned is known to compiler.
	e.g., var obj1; will  throw a compile error since the variable is not initialized
	
	Dynamic
	Dynamically typed - This means the type of variable declared is decided by the compiler at runtime time.
	No need to initialize at the time of declaration. e.g., dynamic str; 
	Errors are caught at runtime 
	Intellisense is not available 
	
12.	REST service (Representational State Transfer)
13.	Entity framework –linq
	ADO.NET entity is an ORM (object relational mapping) which creates a higher abstract object model over ADO.NET components. 
	We can have all data access logic written in higher level languages.
	The underlying data store can be replaced without much overhead since all data access logic is present at a higher level.
	EDMX (Entity Data Model XML) is an XML file which contains all the mapping details of how your objects map with SQL tables. 
	For better performance, disable lazy loading when you are loading a large number of records or use stored procedures.
	
	Below is the difference table which defines each of the approaches. In simple Entity Framework, everything is auto generated and so you need the EDMX XML file as well. POCO is semi-automatic so you have full control on the entity classes but then the context classes are still generated by the EDMX file.

	In Code First, you have complete control on how you can create the entity and context classes. Because you are going to manually create these classes, you do not have dependency on the EDMX XML file. Below is a simple table which shows the cross comparison.

							EDMX		Entity	Context
	Simple entity framework	Needed		Auto	Auto
	POCO approach			Needed		Manual	Auto
	Code First				Not Needed	Manual	Manual

14.	Html5
15.	Wcf-fault contract
	http://dotnetmentors.com/handling-wcf-service-exceptions-using-fault-contracts.aspx
16.	MVC3
	Below are the steps to control flows in MVC (Model, View, and controller) architecture:

	All end user requests are first sent to the controller.
	The controller depending on the request decides which model to load. The controller loads the model and attaches the model with the appropriate view.
	The final view is then attached with the model data and sent as a response to the end user on the browser.
	
	Practically, when a user types a URL in a browser window for an ASP.NET MVC application and presses “go” button, routing engine uses routing rules that are defined in Global.asax file in order to parse the URL and find out the path of corresponding controller.
	
	Temp data - Helps to maintain data when you move from one controller to another controller or from one action to another action. In other words when you redirect, tempdata helps to maintain data between those redirects. It internally uses session variables.
	View data - Helps to maintain data when you move from controller to view.
	View Bag - It’s a dynamic wrapper around view data. When you use Viewbag type, casting is not required. It uses the dynamic keyword internally.
	
	One of the easiest ways of doing validation in MVC is by using data annotations. Data annotations are nothing but attributes which can be applied on model properties. For example, in the below code snippet we have a simple Customer class with a property customercode.
	
	There 12 kinds of results in MVC, at the top is the ActionResult class which is a base class that can have 11 subtypes as listed below:
	ViewResult - Renders a specified view to the response stream
	PartialViewResult - Renders a specified partial view to the response stream
	EmptyResult - An empty response is returned
	RedirectResult - Performs an HTTP redirection to a specified URL
	RedirectToRouteResult - Performs an HTTP redirection to a URL that is determined by the routing engine, based on given route data
	JsonResult - Serializes a given ViewData object to JSON format
	JavaScriptResult - Returns a piece of JavaScript code that can be executed on the client
	ContentResult - Writes content to the response stream without requiring a view
	FileContentResult - Returns a file to the client
	FileStreamResult - Returns a file to the client, which is provided by a Stream
	FilePathResult - Returns a file to the client
17.	MVVM
	The first is a base class for ViewModel classes. This handles the implementation of the INotifyPropertyChanged interface. This interface allows update messages to be passed to the View. 
	
	an ObservableCollection is a collection with an event you can connect to. The event fires when the collection changes
	ObservableCollection is a generic dynamic data collection that provides notifications (using an interface "INotifyCollectionChanged") when items get added, removed, or when the whole collection is refreshed.
	Note: WCF service proxy class in Silverlight will use this type of collection by default.	
	http://www.codeproject.com/Articles/42536/List-vs-ObservableCollection-vs-INotifyPropertyCha
	
	List<T> - Won't update UI whenever items are added, removed or changed
	ObservableCollection<T> - Will update UI only when items are added, removed and not changed
	INotifyPropertyChanged - Will update UI when items are added, removed and changed
		INotifyPropertyChanged is not a collection, it’s an interface used in the data object classes to provide PropertyChanged notification to clients when any property value gets changed. This will allow you to raise PropertyChanged event whenever the state of the object changes (Added, Removed, and Modified) to the point where you want to notify the underlying collection or container that the state has changed.

19.	Asp.net page life cycle
20.	Asp.net cache
21.	OOPs
22.	Satellite assembly
	.NET Framework assembly containing resources specific to a given language. Using satellite assemblies, you can place the 
	resources for different languages in different assemblies, and the correct assembly is loaded into memory only if the user
	elects to view the application in that language.
23.	Trace
24.	SP optimization
	Include SET NOCOUNT ON statement: With every SELECT and DML statement, the SQL server returns a message that indicates the number of affected rows by that statement. This information is mostly helpful in debugging the code, but it is useless after that. By setting SET NOCOUNT ON, we can disable the feature of returning this extra information. 
	
	Use schema name with object name:
	
	Do not use the prefix “sp_” in the stored procedure name: If a stored procedure name begins with “SP_,” then SQL server first searches in the master database and then in the current session database. Searching in the master database causes extra overhead and even a wrong result if another stored procedure with the same name is found in master database.
	
	Use IF EXISTS (SELECT 1) instead of (SELECT *): To check the existence of a record in another table, we uses the IF EXISTS clause. The IF EXISTS clause returns True if any value is returned from an internal statement, either a single value “1” or all columns of a record or complete recordset.
	
	Use the sp_executesql stored procedure instead of the EXECUTE statement.
	The sp_executesql stored procedure supports parameters. So, using the sp_executesql stored procedure instead of the EXECUTE statement improve the re-usability of your code. The execution plan of a dynamic statement can be reused only if each and every character, including case, space, comments and parameter, is same for two statements. 
	
	Try to avoid using SQL Server cursors whenever possible:
	
	Keep the Transaction as short as possible:
	
	Use TRY-Catch for error handling:
	
	Try to avoid dynamic SQL
	
	Avoid unnecessary columns in the SELECT list and unnecessary tables in join conditions
	
	Try to avoid joining between two types of columns	
	
	Try to avoid the use of temporary tables
	Unless really required, try to avoid the use of temporary tables. Rather use table variables.
	In 99% of cases, table variables reside in memory, hence it is a lot faster. Temporary tables reside in the TempDb database. So operating on temporary tables require inter database communication and hence will be slower.

	Try to use UNION to implement an "OR" operation
	
	Implement a lazy loading strategy for large objects
	Store Large Object columns (like VARCHAR(MAX), Image, Text etc.) in a different table than the main table, and put a reference to the large object in the main table.
		
25.	ASP.net page optimization
	Here is the list of checks that you need to run, not necessarily in order:

	Disable ViewState - Set "EnableViewState=false" for any control that does not need the view state. As a general rule if your page does not use postback, then it is usually safe to disable viewstate for the complete page itself.
	
	Use Page.Ispostback is used in Page_Load - Make sure that all code in page_load is within "if( Page.Ispostback)" unless it specifically needs to be executed upon every Page Load.
	
	Asynchronous calls for Web Services - If you are using Web Services in you page and they take long time to load, then preferably use Asynchronous calls to Web Services where ever applicable and make sure to wait for end of the calls before the page is fully loaded. But remember Asynchronous calls have their own overheads, so do not overdo it unless needed.
	
	Use String Builder for large string operations - For any long string operations, use String Builder instead.
	
	Specialized Exception Handling - DO not throw exceptions unless needed, since throwing an exception will give you a performance hit. 
	
	Leave Page Buffering on - Leave Page buffering On, unless specifically required so. Places where you might require to turn it on in case of very large pages so that user can view something while the complete page is loading.
	
	Use Caching - Cache Data whenever possible especially data which you are sure won't change at all or will be reused multiple times in the application. Make sure to have consistent cache keys to avoid any bugs. For simple pages which do not change regularly you can also go for page Caching
	
	Use Script files - As a rule unless required do not insert JavaScript directly into any page, instead save them as script file ".js" and embed them. The benefit being that common code can be shared and also once a script file is loaded into browser cache, it is directly picked up from browser cache instead of downloading again.

	Remove Unused Javascript - Run through all Javascript and make sure that all unused script is removed.
	
	Use the SqlDataReader class - The SqlDataReader class provides a means to read forward-only data stream retrieved from a SQL Server™ database. If you only need to read data then SqlDataReader class offers higher performance than the DataSet class because SqlDataReader uses the Tabular Data Stream protocol to read data directly from a database connection

	Choose appropriate Session State provider - In-process session state is the fastest solution. If you store only small data in session state, go for in-process provider. The out-of-process solutions is useful if you scale your application across multiple processors or multiple computers.

	Use Stored Procedures - Stored procedures are pre-compiled and hence are much faster than a direct SQL statement call.
	
	Return Multiple Resultsets
	
	Avoid Tables. Use Div,span in place of them.

	Place CssClass instead of assigning style on tag. This will reduce the text in html file (as only one class name is replaced by multiple styles)

26.	Access modifier
	public (No restrictions to access).
	protected (Access is limited to within the class definition and any class that inherits from the class).
	internal (Access is limited exclusively to classes defined within the current project assembly).
	private (Access is limited to within the class definition; This is the default access modifier type if none is formally specified).
27.	Latest asp.net version
28.	TFS
29.	What is the difference between internal  and internal protected ?
30.	What is the difference between Hiding and overriding ?
	Hiding: This is a C# Concept by which you can provide a new implementation for the base class member without overriding the member. You can hide a base class member in the derived class by using the keyword "new". The method signature,access level and return type of the hidden member has to be same as the base class member
	
	if base.Hello() is overridden by child.Hello(), then only child.Hello() is seen by outside classes. Using new however, allows both base.Hello() and child.Hello() to be viewed by outside classes, depending on the run-time typecast. 
	
31.	What is the DataSet.CaseSensitive property used for?
32.	Which method can be used to remove forms authentication cookie?
	FormsAuthentication.SignOut();
34.	Whats the difference between RegisterClientScriptBlock, RegisterClientScriptInclude and RegisterClientScriptResource?
37.	What are Creational Design Patterns? 
	creational patterns are design patterns that deal with object creation mechanisms and are used in situations when basic form of object creation could result in design problems or increase complexity of a code base.
38.	Show an implementation of Abstract Factory Pattern ?
39.	What is the MVC Pattern (Model View Controller Pattern)? 
40.	What are all design pattern you have used in your project?
41.	Explain a scenario where you have applied <any pattern name told in previous answer>PATTERN_NAME? and why did you applied this pattern?
42.	In which situation you will use  singleton pattern
43.	How do ensure a Singleton is Threadsafe
44.	What is one-way operation?
45.	Can you explain duplex contracts in WCF?
46.	How can we host a service on two different protocols on a single server?
47.	How can we use MSMQ bindings in WCF?
48.	Can you explain transactions in WCF?
49.	What different transaction isolation levels provided in WCF?
50.	Can we do transactions using MSMQ?
51.	Can we have two-way communications in MSMQ?
52.	Reflection
53.	What’s the difference between LINQ to SQL and Entity framework?
	Linq-To-Sql - LINQ to SQL only supports 1 to 1 mapping of database tables, views, sprocs and functions available in Microsoft SQL Server, use this framework if you plan on editing a one-to-one relationship of your data in your presentation layer.  Meaning you don't plan on combining data from more than one table in any one view or page.
	LINQ To SQL supports only Microsoft SQL Server 2000 and later version and even SQL Server 2000 has some limitations.
	
	Entity Framework - use this framework if you plan on combining data from more than one table in your view or page.
	With Entity Framework you can plug any DB Server i.e. IBM DB2, Sybase SqlAnyWhere, Oracle, SQL Azure, and lot more.
54.	How to join sql table and function?
	select id_num, name, balance, SUM(x.discount) from listOfPeople
    cross apply dbo.calculatePersonalDiscount(listOfPeople.id_num) x
	
	- CROSS APPLY acts as INNER JOIN, returns only rows from the outer table that produce a result set from the table-valued function.
	- OUTER APPLY acts as OUTER JOIN, returns both rows that produce a result set, and rows that do not, with NULL values in the columns produced by the table-valued function.
	
55. SOLID
	SRP-	The Single Responsibility Principle-	A class should have one, and only one, reason to change.
	OCP-	The Open Closed Principle-	You should be able to extend a classes behavior, without modifying it.
	LSP-	The Liskov Substitution Principle-	Derived classes must be substitutable for their base classes.
	ISP-	The Interface Segregation Principle-	Make fine grained interfaces that are client specific.
	DIP-	The Dependency Inversion Principle-	Depend on abstractions, not on concretions.
56. SELECT @@IDENTITY
	It returns the last IDENTITY value produced on a connection, regardless of the table that produced the value, and regardless of the scope of the statement that produced the value.
	@@IDENTITY will return the last identity value entered into a table in your current session. While @@IDENTITY is limited to the current session, it is not limited to the current scope. If you have a trigger on a table that causes an identity to be created in another table, you will get the identity that was created last, even if it was the trigger that created it.

	SELECT SCOPE_IDENTITY()
	It returns the last IDENTITY value produced on a connection and by a statement in the same scope, regardless of the table that produced the value.
	SCOPE_IDENTITY(), like @@IDENTITY, will return the last identity value created in the current session, but it will also limit it to your current scope as well. In other words, it will return the last identity value that you explicitly created, rather than any identity that was created by a trigger or a user defined function.

	SELECT IDENT_CURRENT(‘tablename’)
	It returns the last IDENTITY value produced in a table, regardless of the connection that created the value, and regardless of the scope of the statement that produced the value.
	IDENT_CURRENT is not limited by scope and session; it is limited to a specified table. IDENT_CURRENT returns the identity value generated for a specific table in any session and any scope.
57. Common Table Expressions(CTE)
	CTE allows you to define the subquery at once, name it using an alias and later call the same data using the alias just like what you do with a normal table. 
	With T(Address, Name, Age)  --Column names for Temporary table
	AS
	(
	SELECT A.Address, E.Name, E.Age from Address A
	INNER JOIN EMP E ON E.EID = A.EID
	)
	SELECT * FROM T  --SELECT or USE CTE temporary Table
	WHERE T.Age > 50
	ORDER BY T.NAME
58. Is it possible to use FileUpload control within the update panel?
	Yes, it's possible. But we need to use Postback triggers to upload the file.
59. How many types of triggers are there in update panel?
	There are 2 types of triggers. 
	1. PostBackTrigger : It does a full postback. This is useful when any such control which placed within updatePanel but it cannot work asynchronously. Like File Upload Control. 
	2. AsyncPostBackTrigger :- It does partial post back asynchronously.
60. If there are multiple update panels on the page say Upd1 and Upd2. There is a button placed in Upd1. How can you stop Upd2 to update when button placed in 	upd1 is clicked?

	There is a property called UpdateMode which takes two values 
	1.Always : Default value of this property. 
	2.Conditional 

	When set to conditional, then that updatepanel's content only gets updated when control placed in that update panel does a postback. Control placed in other update panel will not affect this updatepanel.
61. Tell name of all the control of Ajax?

	There are 5 controls. 
	1. ScriptManager 
	2. UpdatePanel 
	3. UpdateProgress 
	4. Timer 
	5. ScriptManageProxy
62. How to control the duration of an AJAX request?

	It is controlled using the AsyncPostBackTimeout property of the ScriptManager control. 

	ex: 
	<asp:ScriptManager runat="server" id="ss" AsyncPostBackTimeout="50"/> 

	AsyncPostBackTimeout value is in seconds (so it is 50 seconds) , before asynchronous postback times out if no response is received. 
	default value is 90 seconds.
63. What is update panel?
	Update panel is a server control. It is used to update specified portion of a web page. To use update panel, we need to use a script manager. 
64. Why is it preferred to not use finalize for clean up?
	The problem with finalize is that garbage collection has to make two rounds in order to remove objects which have finalize methods.
65. Server.Transfer(): client is shown as it is on the requesting page only, but all the content is of the requested page. Data can be persisted across the 	pages using Context.Item collection, which is one of the best ways to transfer data from one page to another keeping the page state alive.
66. Composite Key : 
	A composite key is a combination of more than one column to identify a unique row in a table. 
	Exp : Let say EmpID, EmailID, SSN are columns in Employee table and projectID in project table . 
	if EmpID and project id are put in projectionHours table then combination of empid and project ID called as composite key because combination of these two act as primary key in projectionHours table. 

	Candidate Key: 
	All keys in a table that become unique called as candidate key. 
	Exp : EmpID , EmailID and SSN all will be always unique for any employee in that case all these three columns called as candidate keys. 

	Alternate Key: 
	Among of candidate keys if any single key or combination of keys made as primary key then rest candidate key called as alternate key. 
	Exp : Suppose in employee table EmpID is primary key then Emailid and SSN are called as alternate key mean later on these key can be act as primary key without affecting existing data in table. 
67. hnadler vs module
	An HttpModule will execute for every request to your application, regardless of extension, and is generally used for things like security, statitistics, logging, etc.
	An HttpHandler is generally associated with a specific extension, and is used for things like RSS feeds, dynamic image generation or modification, and the like.
	
	HTTP Handler
 	HTTP Handler is the process which runs in response to a HTTP request. So whenever user requests a file it is processed by the handler based on the extension. So, custom http handlers are created when you need to special handling based on the file name extension. Let's consider an example to create RSS for a site. So, create a handler that generates RSS-formatted XML. Now bind the .rss extension to the custom handler.
	 
	HTTP Modules
	 
	HTTP Modules are plugged into the life cycle of a request. So when a request is processed it is passed through all the modules in the pipeline of the request. So generally http modules are used for:
	 
	Security: For authenticating a request before the request is handled.
	 
	Statistics and Logging: Since modules are called for every request they can be used for gathering statistics and for logging information.

68. Association, Aggregation and Composition
	
	Composition:
	If we were going to model a car, it would make sense to say that an engine is part-of a car. Within composition, the lifetime of the part (Engine) is managed by the whole (Car), in other words, when Car is destroyed, Engine is destroyed along with it
	
	Association is a relationship where all object have their own life cycle and there is no owner. Let’s take an example of Teacher and Student. Multiple students can associate with a single teacher and a single student can associate with multiple teachers but there is no ownership between the objects and both have their own lifecycle. Both can be created and deleted independently.

	Aggregation is a specialized form of Association where all objects have their own lifecycle but there is an ownership: a child object can not belong to another parent object. Let’s take an example of Department and teacher. A single teacher can not belong to multiple departments, but if we delete the department the teacher object will not be destroyed. We can think about it as a “has-a” relationship.

	Composition is again a specialized form of Aggregation and we can call this as a “death” relationship. It is a strong type of Aggregation. Child objects does not have their life cycle and if the parent object is deleted all child objects will also be deleted. Let’s take again an example of relationship between House and rooms. A house can contain multiple rooms and there is no independent life for a room and a room can not belong to two different houses. If we delete the house its rooms will be automatically deleted. Let’s take another example relationship between Questions and options. Single questions can have multiple options and an option can not belong to multiple questions. If we delete a question its options will also be deleted.
	
69. Difference Between Generalization and Specialization
	The process of extracting common characteristics from two or more classes and combining them into a generalized superclass, is called Generalization. The common characteristics can be attributes or methods. Generalization is represented by a triangle followed by a line.

	Specialization is the reverse process of Generalization means creating new sub classes from an existing class.
	Let’s take an example of Bank Account; A Bank Account is of two types – Current Account and Saving Account. Current Account and Saving Account inherits the common/ generalized properties like Account Number, Account Balance etc. from a Bank Account and also have their own specialized properties like interest rate etc.

70. singleton
	public class Singleton
	{
		private static Singleton instance = null;
		private static readonly object padlock = new object();

		private Singleton()
		{
		}

		public static Singleton Instance
		{
			get
			{
				lock (padlock)
				{
					if (instance == null)
					{
						instance = new Singleton();
					}
					return instance;
				}
			}
		}
	}
	
71. Factory	
	The factory pattern method is a popularly used design pattern and it is very useful to restrict clients from knowing the actual business logic methods, it is useful to create a decoupled system, and it is useful to eliminate object creation in a client environment.
	
	ex: Assortment data reader

72. AbstractFactory
	This pattern is particularly useful when the client doesn't know exactly what type to create. As an example, let's say a Showroom exclusively selling cellphones gets a query for the smart phones made by Samsung. Here we don't know the exact type of object to be created (assuming all the information for a phone is wrapped in the form of a concrete object). But we do know that we are looking for smart phones that are manufactured by Samsung. This information can actually be utilized if our design has Abstract factory implementation.
	
73. Observer pattern (Publish-Subscribe)
	The intent of the pattern is to define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.Microsoft calls the class that raises events a publisher and the classes that handle events subscribers6. Notably, it is also known as "Publish-Subscribe"	
Decorator 

74. Decorator 

75. Absatrction
	Abstraction is another good feature of OOPS. Abstraction means to show only the necessary details to the client of the object. Do you know the inner details of the Monitor of your PC? What happen when you switch ON Monitor? Does this matter to you what is happening inside the Monitor? No Right, Important thing for you is weather Monitor is ON or NOT. When you change the gear of your vehicle are you really concern about the inner details of your vehicle engine? No but what matter to you is that Gear must get changed that’s it!! This is abstraction; show only the details which matter to the user. 

76. Encapsulation
		
77. Delegates
	Delegate is a type which  holds the method(s) reference in an object.
	
	In programming Scenario: You are often faced with situations where you need to execute a particular action, but you don’t know in advance which method, or even which object, you’ll want to call upon to execute it.

	For Example: A button might not know which object or objects need to be notified. Rather than wiring the button to a particular object, you will connect the button to a delegate and then resolve that delegate to a particular method when the program executes.
	
	public delegate double Delegate_Prod(int a,int b);
	class Class1
	{
		static double fn_Prodvalues(int val1,int val2)
		{
			return val1*val2;
		}
		static void Main(string[] args)
		{
			//Creating the Delegate Instance
			Delegate_Prod delObj = new Delegate_Prod(fn_Prodvalues);
			Console.Write("Please Enter Values");
			int v1 = Int32.Parse(Console.ReadLine());
			int v2 = Int32.Parse(Console.ReadLine());
			//use a delegate for processing
			double res = delObj(v1,v2);
			Console.WriteLine ("Result :"+res);
			Console.ReadLine();
		}
	}

78. Events
	using System;
	using System.IO;

	namespace Akadia.SimpleEvent
	{
		/* ========= Publisher of the Event ============== */
		public class MyClass
		{
			// Define a delegate named LogHandler, which will encapsulate
			// any method that takes a string as the parameter and returns no value
			public delegate void LogHandler(string message);
	 
			// Define an Event based on the above Delegate
			public event LogHandler Log;
	  
			// Instead of having the Process() function take a delegate
			// as a parameter, we've declared a Log event. Call the Event,
			// using the OnXXXX Method, where XXXX is the name of the Event.
			public void Process()
			{
				OnLog("Process() begin");
				OnLog("Process() end");
			}
	 
			// By Default, create an OnXXXX Method, to call the Event
			protected void OnLog(string message)
			{
				if (Log != null)
				{
					Log(message);
				}
			}
		}
	 
		// The FileLogger class merely encapsulates the file I/O
		public class FileLogger
		{
			FileStream fileStream;
			StreamWriter streamWriter;
	 
			// Constructor
			public FileLogger(string filename)
			{
				fileStream = new FileStream(filename, FileMode.Create);
				streamWriter = new StreamWriter(fileStream);
			}
	 
			// Member Function which is used in the Delegate
			public void Logger(string s)
			{
				streamWriter.WriteLine(s);
			}
	 
			public void Close()
			{
				streamWriter.Close();
				fileStream.Close();
			}
		}
	 
		/* ========= Subscriber of the Event ============== */
		// It's now easier and cleaner to merely add instances
		// of the delegate to the event, instead of having to
		// manage things ourselves
		public class TestApplication
		{
			static void Logger(string s)
			{
				Console.WriteLine(s);
			}
	 
			static void Main(string[] args)
			{
				FileLogger fl = new FileLogger("process.log");
				MyClass myClass = new MyClass();
	 
				// Subscribe the Functions Logger and fl.Logger
				myClass.Log += new MyClass.LogHandler(Logger);
				myClass.Log += new MyClass.LogHandler(fl.Logger);

				// The Event will now be triggered in the Process() Method
				myClass.Process();
	 
				fl.Close();
			}
		}
	}

79. throw; rethrows the original exception and preserves its original stack trace.
	throw ex; throws the original exception but resets the stack trace, destroying all stack trace information until your catch block.
	NEVER write throw ex;

80. SOA architecture
	A service-oriented architecture (SOA) is the underlying structure supporting communications between services. SOA defines how two computing entities, such as programs, interact in such a way as to enable one entity to perform a unit of work on behalf of another entity. Service interactions are defined using a description language. Each interaction is self-contained and loosely coupled, so that each interaction is independent of any other interaction.
	Simple Object Access Protocol (SOAP)-based Web services are becoming the most common implementation of SOA. However, there are non-Web services implementations of SOA that provide similar benefits. The protocol independence of SOA means that different consumers can communicate with the service in different ways.
	
	Distributed architecture

81. Static class and single ton pattern
	Static classes and singletons both provide sharing of redundant objects in memory, but they are very different in usage and implementation. 

	Static Class - You can not create the instance of static class. 
	Singleton pattern - you can create one instance of the object and reuse it. 
	Static classes- are loaded automatically by the .NET Framework common language runtime (CLR) when the program or namespace containing the class is loaded. 
	Singleton instance is created for the first time when the user requested. 
	Static Class class cannot have constructor. 
	singleton class can have constructor.
	
	in case of singleton class you can create the object of singleton class and pass it to method but we can not pass the static class to method. 
	
	we can dispose the objects of a singleton class but not of static class 

82. WEB Api
	ASP.NET Web API is a framework that makes it easy to build HTTP services that reach a broad range of clients, including browsers and mobile devices. ASP.NET Web API is an ideal platform for building RESTful applications on the .NET Framework.
	
	ASP.NET Web API is a framework that makes it easy to build HTTP services that reach a broad range of clients, including browsers and mobile devices. With WebAPI content negotiation, we can return data based on the client requests. What I mean is, if the client is requesting the data to be returned as JSON or XML, the WebAPI framework deals with the request type and returns the data appropriately based on the media type. By default WebAPI provides JSON and XML based responses.

	WebAPI is an ideal platform for building pure HTTP based services where the request and response happens with HTTP protocol. The client can make a GET, PUT, POST, and DELETE request and get the WebAPI response appropriately.

	In summary, the WebAPI is 

	An HTTP Service 
	Designed for broad reach 
	Uses HTTP as an Application protocol, not a transport protocol

83. Finalize
	Provide implicit control by implementing the protected Finalize on an object (destructor syntax in C# and C++). The garbage collector calls this method at some point after there are no longer any valid references to the object.
	Internally, it is called by Garbage Collector and cannot be called by user code.
	
	Dispose
	In some cases, you might want to provide programmers using an object with the ability to explicitly release these external resources before the garbage collector frees the object. To provide explicit control, implement the Dispose provided by the IDisposable. The consumer of the object should call this method when it is finished using the object.
	Explicitly, it is called by user code and the class implementing dispose method must implement IDisposable interface.
	
	There are a couple of resources which GC is not able to release as it doesn't have information that, how to claim memory from those resources like File handlers, window handlers, network sockets, database connections etc. If your application these resources than it's programs responsibility to release unmanaged resources. For example, if we open a file in our program and not closed it after processing than that file will not be available for other operation or it is being used by other application than they can not open or modify that file. For this purpose FileStream class provides Dispose method. We must call this method after file processing finished. Otherwise it will through exception Access Denied or file is being used by other program.
	
84.	Jagged arrary
	A jagged array is an array whose elements are arrays. The elements of a jagged array can be of different dimensions and sizes. A jagged array is sometimes called an "array of arrays."

85.	Structure VS Class
	The general rule to follow is that structs should be small, simple (one-level) collections of related properties.
	For example, say you have a class SimpleClass with two properties, A and B. You instantiate a copy of this class, initialize A and B, and then pass the instance to another method. That method further modifies A and B. Back in the calling function (the one that created the instance), your instance's A and B will have the values given to them by the called method.

	Now, you make it a struct. The properties are still mutable. You perform the same operations with the same syntax as before, but now, A and B's new values aren't in the instance after calling the method. What happened? Well, your class is now a struct, meaning it's a value type. If you pass a value type to a method, the default (without an out or ref keyword) is to pass "by value"; a shallow copy of the instance is created for use by the method, and then destroyed when the method is done leaving the initial instance intact.
	
	Classes Only:
	Can support inheritance
	Are reference (pointer) types
	The reference can be null
	Have memory overhead per new instance
	
	Structs Only:
	Cannot support inheritance
	Are value types
	Are passed by value (like integers)
	Cannot have a null reference (unless Nullable is used)
	Do not have a memory overhead per new instance - unless 'boxed'
	
	Both Classes and Structs:
	Are compound data types typically used to contain a few variables that have some logical relationship
	Can contain methods and events
	Can support interfaces

86.	structs and Interface
	The fact that a struct can implement an interface is well known and so is the fact that casting a value type into an interface leads to boxing of the value type. This is because methods in interfaces are defined as virtual and to resolve virtual references, vtable (method table) look up is required. Since value types do not have pointers to vtable they are first boxed into a reference type and then the look up happens.
	
87.	Derived table
	A derived table is basically a subquery, except it is always in the FROM clause of a SQL statement. The reason it is called a derived table is because it essentially functions as a table as far as the entire query is concerned.
	
	- derived tables are used in the FROM clause
	- subqueries are used in the WHERE clause, but can also be used to select from one table and insert into another.

88.	Use of instead of trigger
	An INSTEAD OF trigger can be defined to perform error or value checking on one or more columns, and then perform additional actions before inserting the record. For example, when the value being updated in an hourly wage column in a payroll table exceeds a specified value, a trigger can be defined to either produce an error message and roll back the transaction, or insert a new record into an audit trail before inserting the record into the payroll table

89.	Sql temp table and table variable 
	Temporary Tables are real tables so you can do things like CREATE INDEXes, etc.
	Table variables don't participate in transactions, logging or locking. This means they're faster as they don't require the overhead, but conversely you don't get those features. So for instance if you want to ROLLBACK midway through a procedure then table variables populated during that transaction will still be populated!
	Temp tables might result in stored procedures being recompiled, perhaps often. Table variables will not.
	Both table variables and temp tables are stored in tempdb.
	Global Temp Tables (##tmp) are another type of temp table available to all sessions and users.

90. Inetrface
	An interface contains only the signatures of methods, properties, events or indexers.
	
91. Indexer
	Indexers are a syntactic convenience that enable you to create a class, struct, or interface that client applications can access just as an array. Indexers are most frequently implemented in types whose primary purpose is to encapsulate an internal collection or array.
	
	private float[] temps = new float[10] { 56.2F, 56.7F, 56.5F, 56.9F, 58.8F, 61.3F, 65.9F, 62.1F, 59.2F, 57.5F };
	public float this[int index]
    {
        get
        {
            return temps[index];
        }

        set
        {
            temps[index] = value;
        }
    }
	
	
92.	Use of private constructor
	A private constructor means that the class can't be instantiated from outside the class: the only way to create an instance of the class is by calling a static method within the class which creates an instance, or returns a reference to an existing instance.
	
	A static class can never be instantiated. No way, no how.

	A non-static class with a private constructor but all static methods can be abused in various ways - inheritance, reflection, call the private constructor in a static factory - to instantiate the class.
	
	Static constructor will be called first time when the class is referenced. Static constructor is used to initialize static members of the class.
	In the non static class the private or public constructor will not be called. Static members will not be initialized either by private or public constructor.

93. Using ASP.Net AJAX ScriptManager , you can call Server Side ASP.Net methods from client side without any PostBack using PageMethods.

94. Composite control
	Composite controls are controls that combine multiple controls together to form a new reusable control.  For example, a simple composite control could consist of both a Label control and a TextBox control.

95. Event bubbling
	Event bubbling is used by the data-bound controls (Repeater, DataList, and DataGrid) to expose command events raised by child controls (within item templates) as top-level events.
	
	Handling(tracking) child controls events (only button type child controls) through parent control in data bind controls known as event bubbling.

	Server controls like Datagrid, DataList, and Repeater can have other child controls inside them.

	Example DataGrid can have combo box inside datagrid. These child control do not raise there events by themselves, rather they pass the event to the container parent (which can be a datagrid,datalist, repeater), which passed to the page as "ItemCommand" event. As the child control send events to parent it is termed as event bubbling.
	
96. Adaptor pattern